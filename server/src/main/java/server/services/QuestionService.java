package server.services;


import commons.Activity;
import commons.EstimationQuestion;
import commons.MultipleActivitiesQuestion;
import commons.MultipleChoiceQuestion;
import commons.Question;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.PutMapping;
import server.api.ActivityController;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.Arrays;


@RestController
@RequestMapping("/api/questions")
public class QuestionService {

    private ActivityController activityController;
    private List<Question> allQuestions = new ArrayList<>();
    private boolean[] enabledQuestionTypes = new boolean[]{true, true, true};

    /**
     * Constructor.
     *
     * @param activityController That's going to be used to get random actiivities.
     */
    public QuestionService(ActivityController activityController) {
        this.activityController = activityController;
    }

    /**
     * Method that returns a random question.
     *
     * @return the list of all questions we'll use in the quiz.
     */
    public List<Question> generateRandomQuestions() {
        if (activityController.getAll().size() < 20) {
            activityController.loadDefaultDatabase();
        }
        Set<Activity> baseActivities = new HashSet<>();

        for (int i = 0; i < 20; i++) {
            Activity activity = activityController.getRandomActivity().getBody();
            while (baseActivities.contains(activity)) {
                activity = activityController.getRandomActivity().getBody();
            }
            baseActivities.add(activity);
        }

        return generateSomeKindQuestions(baseActivities, Arrays.copyOf(enabledQuestionTypes,
                enabledQuestionTypes.length)); // deep copy of the array, type change during the generation is isolated
    }           // normally arrays.copy is creating shallow copy, but there are no reference for primitive types

    /**
     * Generate Some kind of questions based on the admin's configuration.
     * @param baseActivities a Set where the questions are based on.
     * @param currentEnabledTypes an Array consists with boolean value.
     *                   True means generation for that kind of question is enabled.
     *                   False means generation for that kind of question is disabled.
     * @return A list of questions.
     */
    public List<Question> generateSomeKindQuestions(Set<Activity> baseActivities, boolean[] currentEnabledTypes) {
        List<Question> questions = new ArrayList<>();
        Random random = new Random();

        for (Activity activity : baseActivities) {

            int chooseType =  random.nextInt(3);
            while (!currentEnabledTypes[chooseType]) {
                chooseType = random.nextInt(3);
            }

            switch (chooseType) {
                case 0:
                    questions.add(EstimationQuestion.generateQuestion(activity));
                    break;
                case 1:
                    questions.add(generateMAQuestion(activity));
                    break;
                default:
                    questions.add(MultipleChoiceQuestion.generateQuestion(activity));
                    break;
            }
        }
        this.allQuestions = questions;
        return questions;
    }

    /**
     * Method for generating a new Open Question.
     *
     * @param activity the base activity
     * @return a new Open Question
     */
    public Question generateMAQuestion(Activity activity) {
        List<Activity> answerActivities = new ArrayList<>();
        answerActivities.add(activity);
        Random rand = new Random();
        for (int i = 0; i < 2; i++) {
            Activity answerActivity = activityController.getRandomActivity().getBody();
            while (answerActivities.contains(answerActivity)) {
                answerActivity = activityController.getRandomActivity().getBody();
            }
            answerActivities.add(answerActivity);
        }
        return MultipleActivitiesQuestion.generateQuestion(answerActivities, rand);
    }

    /**
     * Get api endpoint for getting all the questions generated for a game.
     *
     * @return all the questions generated
     */
    @GetMapping("all")
    public List<Question> getAll() {
        generateRandomQuestions();
        return allQuestions;
    }

    /**
     * Give the types of question that are generated by the server.
     *
     * @return The boolean array which indicates if a type of question is
     *         generated by the server.
     *         0 - Estimation Question
     *         1 - Multiple Activity Question
     *         2 - Multiple Choice Question
     */
    @GetMapping("types")
    public boolean[] getTypes() {
        return enabledQuestionTypes;
    }

    /**
     * Update the types of question that can be generated.
     * Check if the update types are all false.
     * This is checked by the client side already, a client can never trigger this exception.
     * Unless we use PostMan to pass an array [false,false,false]
     *
     * @param selectedTypes The boolean array which contains which type of questions
     *                      should be generated for the game.
     *                      0 - Estimation Question
     *                      1 - Multiple Activity Question
     *                      2 - Multiple Choice Question
     */
    @PutMapping("update-types")
    public void updateTypes(@RequestBody Boolean[] selectedTypes) {
        if (!(selectedTypes[0] || selectedTypes[1] || selectedTypes[2])) {
            throw new IllegalArgumentException("\nAt least one Type of question must be enabled!\n");
        }

        for (int i = 0; i < selectedTypes.length; i++) {
            enabledQuestionTypes[i] = selectedTypes[i];
        }
    }
}
